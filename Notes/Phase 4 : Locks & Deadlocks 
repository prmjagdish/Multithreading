Goal :
    âœ” Fine-grained locking
    âœ” Understand how deadlocks happen
    âœ” Learn how to prevent them

+ ReentrantLock

    ReentrantLock is an explicit lock from java.util.concurrent.locks.

    Lock lock = new ReentrantLock();

    Why not synchronized?
    synchronized	        ReentrantLock
    Implicit	            Explicit
    No try	                tryLock()
    No fairness	            Fair / Unfair
    One lock style	        Flexible

    Basic usage
    lock.lock();
    try {
        // critical section
    } finally {
        lock.unlock();
    }

    ğŸ‘‰ finally is mandatory â€” forgetting unlock() = ğŸ’€ bug

+ tryLock()

    Instead of blocking forever, you can try to get a lock.

    if (lock.tryLock()) {
        try {
            // got the lock
        } finally {
            lock.unlock();
        }
    } else {
        // couldn't get lock
    }

    Timed version (deadlock-friendly):

    if (lock.tryLock(100, TimeUnit.MILLISECONDS)) {
        ...
    }

+ Fair vs Unfair Locks

    Lock fairLock = new ReentrantLock(true);   // fair
    Lock unfairLock = new ReentrantLock(false); // default

    Fair lock
    Threads acquire lock in FIFO order
    Less starvation
    Slower

    Unfair lock (default)
    Faster
    Possible starvation
    Used most of the time

+ What is a Deadlock?

    A deadlock happens when:
    Thread A holds Lock 1 â†’ waits for Lock 2
    Thread B holds Lock 2 â†’ waits for Lock 1

    ğŸ” Nobody moves. Ever.