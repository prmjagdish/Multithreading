Goal : Understand why concurrency causes bugs ‚Äî and how Java fixes them

+ Race Conditions (the root of evil)
    What is a race condition?
    When:

    Multiple threads
    Access shared mutable state
    Without coordination
    ‚Ä¶and the result depends on timing.

    Classic example
    balance = balance + amount;

+ Critical Section
    A critical section is code that:
    Accesses shared data
    Must be executed by only one thread at a time

    Example:
    balance += amount; // critical section

    üëâ If two threads enter here together ‚Üí corruption

+ synchronized keyword (your first real weapon)
    What it does
    Ensures mutual exclusion
    Only one thread can enter the block/method at a time
    Uses an intrinsic lock (monitor)

    Method-level
    public synchronized void deposit(int amount) {
        balance += amount;
    }

    Block-level
    public void withdraw(int amount) {
        synchronized (this) {
            balance -= amount;
        }
    }

+ Intrinsic Locks (important mental model)
    Every Java object has one lock.
    synchronized(this) ‚Üí lock on current object
    synchronized(account) ‚Üí lock on account instance
    Static synchronized ‚Üí lock on Class object

    If two threads synchronize on different objects, they do NOT block each other.

+ Atomic Variables (lock-free safety)
    For simple operations:
    AtomicInteger balance = new AtomicInteger(0);
    balance.addAndGet(100);
    balance.get();

    ‚úî Thread-safe
    ‚úî Faster than synchronized
    ‚ùå Limited (can‚Äôt guard multiple variables together)

‚úî Race conditions are timing bugs
‚úî Critical sections must be protected
‚úî synchronized uses intrinsic locks
‚úî Locks are per-object, not per-method
‚úî Atomics ‚â† replacement for all locks